import flixel.FlxG;
import flixel.group.FlxTypedGroup;
import funkin.graphics.FunkinSprite;
import funkin.input.Controls.Control;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ScriptedModule;
import funkin.PlayerSettings;
import funkin.save.Save;
import funkin.ui.AtlasText;
import funkin.ui.ButtonStyle;
import funkin.ui.options.ControlsMenu;
import funkin.ui.options.OptionsState;
import funkin.ui.Prompt;
import funkin.ui.TextMenuItem;
import funkin.util.FileUtilSandboxed;
import funkin.util.FileWriteMode;
import funkin.util.InputUtil;
import funkin.util.SerializerUtil;
import haxe.ds.IntMap;
import haxe.ds.StringMap;
import Lambda;

class ControlsAPI extends ScriptedModule {
  public static var instance:ControlsAPI;

  public static final COLUMNS = 2;

  var controlSlots:Null<Array<ControlSlot>> = Save.instance.modOptions.get("customControls") ?? [];
  var headerSlots:Null<Array<HeaderSlot>> = Save.instance.modOptions.get("customHeaders") ?? [];
  var removedEntries:Null<Array<RemovedEntry>> = [];
  var removedEntriesData:Null<{entries:Array<RemovedEntry>}>;

  public static var SPRITES:StringMap<Dynamic>;
  var controlSprites:FlxTypedGroup<FunkinSprite>;

  var slotToSprIndex:IntMap<Int>;

  var controlsMenu:ControlsMenu;
  var prompt:Prompt;

  function new() {
    super("ControlsImpl");
    ControlsAPI.instance = this;

    SPRITES = new StringMap();
    SPRITES.set("NOTES", [
      "left" => "left",
      "down" => "down",
      "up" => "up",
      "right" => "right"
    ]);

    if (FileUtilSandboxed.fileExists(Assets.getPath("removedControls.json"))) {
      removedEntriesData = FileUtilSandboxed.readJSONFromPath(Assets.getPath("removedControls.json"));
      if (removedEntriesData != null && removedEntriesData.entries != null) removedEntries = removedEntriesData.entries;
    }
  }

  // API Methods
  public function registerHeader(name:String, ?index:Int, ?centered:Bool, ?font:String):Int {
    for (i in 0...headerSlots.length) {
      if (headerSlots[i].name == name) {
        trace("[CustomControls] Cannot register header '" + name + "' a header slot with the same name already exists.");
        return i;
      }
    }

    if (centered == null) centered = true;

    var slot:HeaderSlot = {name:name, index:index, centered:centered};
    if (font != null) slot.font = font;

    headerSlots.push(slot);

    Save.instance.modOptions.set("customHeaders", headerSlots);
    Save.instance.flush();
    trace("[CustomControls] Registered header " + name);
    return headerSlots.length - 1;
  }

  public function registerKeybind(name:String, keys:Array<Int>, ?header:String, ?inputTypes:Array<String>, ?index:Int, ?spritePath:String):Int {
    for (i in 0...controlSlots.length) {
      if (controlSlots[i].name == name) {
        trace("[CustomControls] Cannot register keybind '" + name + "' a control slot with the same name already exists.");
        return i;
      }
    }

    if (index == null) index = -1;

    inputTypes = inputTypes ?? ["justPressed", "justReleased"];
    var inputs:Array<Int> = [];
    for (input in inputTypes) inputs.push(InputsUtil.inputFromStr(input));

    if (spritePath != null) spritePath = "ui/controls/" + spritePath;

    var slot:ControlSlot = {name:name, keys:keys, index:index, inputTypes:inputs, spritePath:spritePath};
    if (header != null) slot.header = header;
    controlSlots.push(slot);

    Save.instance.modOptions.set("customControls", controlSlots);
    Save.instance.flush();
    trace("[CustomControls] Registered keybind " + name);
    return controlSlots.length - 1;
  }

  public function unregisterHeader(name:String) {
    headerSlots = headerSlots.filter(slot -> slot.name != name);

    Save.instance.modOptions.set("customHeaders", headerSlots);
    Save.instance.flush();
    trace("[CustomControls] Unregistered header " + name);
    return headerSlots.length - 1;
  }

  public function unregisterKeybind(name:String) {
    controlSlots = controlSlots.filter(slot -> slot.name != name);

    Save.instance.modOptions.set("customControls", controlSlots);
    Save.instance.flush();
    trace("[CustomControls] Unregistered keybind " + name);
    return controlSlots.length - 1;
  }

  public function removeBaseEntry(name:String, ?storeKeys:Bool) {
    for (i in 0...removedEntries.length) {
      if (removedEntries[i].name == name) {
        trace("[CustomControls] Already removed base control entry '" + name + "'.");
        return i;
      }
    }

    if (storeKeys == null) storeKeys = true;
    var entry:RemovedEntry = {name: name};
    if (storeKeys) {
      entry.type = "keybind";
      entry.keys = [];
    }

    removedEntries.push(entry);

    var data = {entries: removedEntries};
    FileUtilSandboxed.writeStringToPath(Assets.getPath("removedControls.json"), SerializerUtil.toJSON(data), FileWriteMode.Force);

    trace("[CustomControls] Registered for removal " + name);
    return removedEntries.length - 1;
  }

  public function readdBaseEntry(name:String) {
    var entry = Lambda.find(removedEntries, e -> e.name == name);
    if (entry == null) {
      trace("[CustomControls] No removed entry found for '" + name + "'.");
      return;
    }

    trace(entry.control);
    PlayerSettings.player1.controls.bindKeys(entry.control, entry.keys);
    PlayerSettings.player1.saveControls();

    removedEntries.remove(entry);

    var data = {entries: removedEntries};
    FileUtilSandboxed.writeStringToPath(Assets.getPath("removedControls.json"), SerializerUtil.toJSON(data), FileWriteMode.Force);

    trace("[CustomControls] Re-added base entry '" + name + "'.");
  }

  // Controls Menu Replacement
  override function onStateChangeEnd(event:StateChangeScriptEvent) {
    if (!(event.targetState is OptionsState)) return;

    controlsMenu = event.targetState.optionsCodex.pages.get("controls");
    if (controlsMenu == null) return;
    controlsMenu.onExit.add(onControlsExit);

    prompt = new Prompt("\nPress any key to rebind\n\n\nBackspace to unbind\n    Escape to cancel", ButtonStyle.None);
    prompt.create();
    prompt.createBgFromMargin(100, -328339);
    prompt.back.scrollFactor.set(0, 0);
    prompt.exists = false;

    // Clearing and readding
    var headers:FlxTypedGroup<AtlasText> = controlsMenu.members[1].members.copy();
    var keyBinds = controlsMenu.controlGrid.members.copy();
    var labels = controlsMenu.labels.members.copy();

    controlsMenu.members[1].clear();
    controlsMenu.controlGrid.clear();
    controlsMenu.labels.clear();

    controlSprites = new FlxTypedGroup();
    slotToSprIndex = new IntMap();
    controlsMenu.add(controlSprites);

    trace("[CustomControls] Adding extra headers: " + headerSlots);
    trace("[CustomControls] Adding extra keybinds: " + controlSlots);
    trace("[CustomControls] Removing entries: " + removedEntries);
    buildControls(headers, keyBinds, labels);

    controlsMenu.controlGrid.onChange.removeAll();
    controlsMenu.controlGrid.onChange.add(selected -> {
      controlsMenu.camFollow.y = selected.y;
      controlSprites.forEach(label -> label.alpha = 0.6);
      controlsMenu.labels.forEach(label -> label.alpha = 0.6);
      controlsMenu.labels.members[Std.int(controlsMenu.controlGrid.selectedIndex / 2)].alpha = 1.0;

      if (slotToSprIndex.exists(controlsMenu.controlGrid.selectedIndex))
        controlSprites.members[slotToSprIndex.get(controlsMenu.controlGrid.selectedIndex)].alpha = 1.0;
    });

    controlsMenu.add(prompt);
  }

  override public function onStateCreate(event:ScriptEvent) {
    if (FlxG.state is OptionsState) return;

    if (controlSprites != null) controlSprites.destroy();
    controlSprites = null;
  }

  // Building headers and labels with keybindings
  function buildControls(ogHeaders:FlxTypedGroup<AtlasText>, keyBinds:Array<InputItem>, labels:Array<AtlasText>) {
    var yPos:Float = controlsMenu.deviceList == null ? 30 : 120;
    var spacer = 70;
    var headerSpacer = 90;

    var labelMap = buildLabelMap(labels, ogHeaders);
    var orderedHeaders = getOrderedHeaders(ogHeaders);
    var globalControlIndex = 0;

    for (headerSlot in orderedHeaders) {
      var headerText = new AtlasText(ControlsMenu.CONTROL_BASE_X, yPos, headerSlot.name, headerSlot.font ?? "bold");
      if (headerSlot.centered ?? true) headerText.screenCenter(0x01);
      headerText.alpha = 0.9;
      controlsMenu.members[1].add(headerText);
      yPos += headerSpacer;

      var originalControls = labelMap.get(headerSlot.name) ?? [];
      var customControls = controlSlots.filter(slot -> slot.header == headerSlot.name);

      var mergedControls = mergeControls(originalControls, customControls, globalControlIndex);

      for (entry in mergedControls) {
        if (entry.isCustom) addCustomControl(entry.slot, entry.slotIndex, yPos);
        else addOriginalControl(entry.originalLabel, keyBinds, entry.originalIndex, yPos, headerSlot.name);

        yPos += spacer;
      }

      globalControlIndex += originalControls.length;
    }
  }

  function addCustomControl(slot:ControlSlot, arrayIndex:Int, y:Float) {
    var label = controlsMenu.labels.add(new AtlasText(ControlsMenu.CONTROL_BASE_X, y, slot.name, "bold"));
    label.alpha = 0.6;
    var labelX = label.x;

    if (slot.spritePath != null) addControlSprite(slot.spritePath, label, y);

    createKeyBinds(slot, arrayIndex, labelX, y);
  }

  function addOriginalControl(label:AtlasText, keyBinds:Array<InputItem>, originalIndex:Int, y:Float, header:String) {
    var removedEntry = Lambda.find(removedEntries, e -> e.name == label.text);
    if (removedEntry != null && removedEntry.type == "keybind") {
      if (removedEntry.keys.length == 0) {
        var startBindIndex = originalIndex * 2;
        for (column in 0...COLUMNS) {
          var bindIndex = startBindIndex + column;
          if (bindIndex < keyBinds.length) {
            var item = keyBinds[bindIndex];
            removedEntry.keys = PlayerSettings.player1.controls.getInputsFor(item.control, item.device);
            removedEntry.control = item.control;

            PlayerSettings.player1.controls.unbindKeys(item.control, removedEntry.keys);
            PlayerSettings.player1.saveControls();
          }
        }

        var data = {entries: removedEntries};
        FileUtilSandboxed.writeStringToPath(Assets.getPath("removedControls.json"), SerializerUtil.toJSON(data), FileWriteMode.Force);
        trace("[CustomControls] Stored keys for removed entry: " + label.text + " = " + removedEntry.keys);
      }
      return;
    }

    label.y = y;
    controlsMenu.labels.add(label);

    if (SPRITES.exists(header)) {
      var headerSprites = SPRITES.get(header);
      var controlName = label.text.toLowerCase();
      if (headerSprites.exists(controlName)) {
        var spritePath = "ui/controls/" + header + "_" + controlName;
        addControlSprite(spritePath, label, y);
      }
    }

    var startBindIndex = originalIndex * 2;
    for (column in 0...COLUMNS) {
      var bindIndex = startBindIndex + column;
      if (bindIndex < keyBinds.length) {
        var item = keyBinds[bindIndex];
        item.y = y;
        controlsMenu.itemGroups[column].push(item);
        controlsMenu.controlGrid.addItem(item.name, item);
      }
    }
  }

  function addControlSprite(spritePath:String, label:AtlasText, y:Float) {
    var spr = FunkinSprite.create(30, y + 10, spritePath);
    spr.setGraphicSize(label.height, label.height);
    spr.updateHitbox();
    spr.alpha = 0.6;
    label.x += spr.width;

    var currentControlIndex = controlsMenu.controlGrid.members.length;
    var spriteIndex = controlSprites.length;
    slotToSprIndex.set(currentControlIndex, spriteIndex);
    slotToSprIndex.set(currentControlIndex + 1, spriteIndex);

    controlSprites.add(spr);
  }

  function createKeyBinds(slot:ControlSlot, index:Int, labelX:Float, labelY:Float) {
    var controlsArray = slot.keys.map(InputUtil.getKeyName);
    for (k in 0...controlsArray.length) if (slot.keys[k] == 0) controlsArray[k] = "---";

    var persIndex = index;
    for (column in 0...COLUMNS) {
      var item:TextMenuItem = new TextMenuItem(labelX + ControlsMenu.CONTROL_MARGIN_X + column * ControlsMenu.CONTROL_SPACING_X, labelY, controlsArray[column], "default",
      () -> selectBind(controlsMenu, persIndex, column));
      item.fireInstantly = true;
      controlsMenu.itemGroups[column].push(item);
      controlsMenu.controlGrid.addItem(item.name, item);
    }
  }

  function mergeControls(originalControls:Array<{label:AtlasText, index:Int}>, customControls:Array<ControlSlot>, baseIndex:Int):Array<ControlEntry> {
    var result:Array<ControlEntry> = [];

    // Create entries for original controls
    for (i in 0...originalControls.length) {
      result.push({
        pos: i, isCustom: false, originalLabel: originalControls[i].label, originalIndex: originalControls[i].index, slot: null, slotIndex: -1
      });
    }

    // Insert custom controls at specified positions
    for (slot in customControls) {
      var arrayIndex = controlSlots.indexOf(slot);
      var insertPos = slot.index;

      // Position at end if -1 or longer (until the position exists)
      if (insertPos < 0 || insertPos > result.length) insertPos = result.length;

      result.insert(insertPos, {
        pos: insertPos, isCustom: true, originalLabel: null, originalIndex: -1, slot: slot, slotIndex: arrayIndex
      });

      for (i in (insertPos + 1)...result.length) result[i].pos++;
    }

    return result;
  }

  function getOrderedHeaders(headers:FlxTypedGroup<AtlasText>) {
    var result:Array<HeaderSlot> = [];
    var headerMap:StringMap<Bool> = new StringMap();

    for (i in 0...headers.length) {
      var header:AtlasText = headers[i];

      // Skip if this header is marked for removal
      if (Lambda.exists(removedEntries, e -> e.name == header.text)) continue;

      var slot:HeaderSlot = {name: header.text, index: i};
      result.push(slot);
      headerMap.set(header.text, true);
    }

    for (headerSlot in headerSlots) {
      if (!headerMap.exists(headerSlot.name)) {
        if (headerSlot.index >= 0 && headerSlot.index < result.length) {
          result.insert(headerSlot.index, headerSlot);
        } else {
          result.push(headerSlot);
        }
        headerMap.set(headerSlot.name, true);
      }
    }

    return result;
  }

  function buildLabelMap(labels:Array<AtlasText>, headers:FlxTypedGroup<AtlasText>):StringMap<Array<{label:AtlasText, index:Int}>> {
    var map:StringMap<Array<{label:AtlasText, index:Int}>> = new StringMap();
    for (i in 0...labels.length) {
      var label = labels[i];

      //if (Lambda.exists(removedEntries, e -> e.name == label.text)) continue;

      var headerName = getHeaderForLabel(label, headers);
      if (!map.exists(headerName)) map.set(headerName, []);
      map.get(headerName).push({label: label, index: i});
    }

    return map;
  }

  function getHeaderForLabel(label:AtlasText, headers:FlxTypedGroup<AtlasText>):String {
    var chosenHeader:String = "";
    for (header in headers) {
      if (header.y <= label.y) chosenHeader = header.text;
      else break;
    }
    return chosenHeader;
  }

  function onControlsExit() {
    ControlsManager.instance.refreshKeyBinds();
  }

  // Promt handling
  var selSlot = -1;
  var selKey = -1;
  var keyUsedToEnterPrompt:Int;

  override function onUpdate(event:UpdateScriptEvent) {
    if (controlsMenu == null || !prompt.exists) return;

    var key:Int = FlxG.keys.firstJustReleased();
    if (key == -1 || key == keyUsedToEnterPrompt) return;

    switch (key) {
      case 27: // Escape
        closePrompt();
      case 8: // Backspace
        onInputSelect(0);
        closePrompt();
      default:
        onInputSelect(key);
        closePrompt();
    }
  }

  function selectBind(controlsMenu:ControlsMenu, slot:Int, keyIndex:Int) {
    selSlot = slot;
    selKey = keyIndex;
    keyUsedToEnterPrompt = FlxG.keys.firstJustPressed();

    controlsMenu.controlGrid.enabled = false;
    controlsMenu.canExit = false;
    prompt.exists = true;
  }

  function onInputSelect(input:Int) {
    var newControlName = InputUtil.getKeyName(input);
    if (input == 0) newControlName = "---";
    controlsMenu.controlGrid.members[controlsMenu.controlGrid.selectedIndex].label.text = newControlName;

    controlSlots[selSlot].keys[selKey] = input;
  }

  function closePrompt() {
    prompt.exists = false;
    controlsMenu.controlGrid.enabled = true;
    controlsMenu.canExit = true;
  }
}

typedef RemovedEntry = {name:String, type:String, control:Control, keys:Array<Int>}
typedef ControlEntry = {pos:Int, isCustom:Bool, originalLabel:Null<AtlasText>, originalIndex:Int, slot:Null<ControlSlot>, slotIndex:Int}
typedef ControlSlot = {name:String, keys:Array<Int>, header:String, index:Int, inputTypes:Array<Int>, spritePath:String}
typedef HeaderSlot = {name:String, index:Int, centered:Bool, font:String}